From 9fca5483818a457e11a5eeabfb487ebb71847d0d Mon Sep 17 00:00:00 2001
From: Alexey Minnekhanov <alexeymin@postmarketos.org>
Date: Mon, 3 Jun 2024 11:05:41 +0300
Subject: [PATCH] build fixes

---
 app/aboot/aboot.c                         |  24 ++-
 app/aboot/fastboot.c                      |   6 +-
 arch/arm/mmu.c                            |   4 +
 dev/gcdb/display/gcdb_display.c           |  32 +--
 dev/gcdb/display/panel_display.c          |   6 +
 dev/pmic/pm8x41/pm8x41_vib.c              |   1 +
 dev/vib/vibrator.c                        |   3 +-
 include/string.h                          |   5 +
 kernel/main.c                             |   2 +
 lib/debug/debug.c                         |   7 +-
 lib/fs/ext2/dir.c                         |   4 +-
 lib/libc/string/rules.mk                  |   1 +
 lib/libc/string/strtol.c                  | 242 ++++++++++++++++++++++
 lib/libfdt/fdt_overlay.c                  |   2 +-
 platform/init.c                           |   2 +-
 platform/msm8226/include/platform/iomap.h |   3 +
 platform/msm8226/msm8226-clock.c          |   4 +-
 platform/msm8226/platform.c               |   1 +
 platform/msm8916/acpuclock.c              |   3 +
 platform/msm8916/include/platform/iomap.h |   8 +
 platform/msm8916/msm8916-clock.c          |   8 +-
 platform/msm8916/platform.c               |   1 +
 platform/msm8974/acpuclock.c              |   4 +
 platform/msm8974/include/platform/iomap.h |   3 +
 platform/msm8974/msm8974-clock.c          |  16 +-
 platform/msm8974/platform.c               |   1 +
 platform/msm_shared/board.c               |   2 +
 platform/msm_shared/boot_stats.c          |   4 +
 platform/msm_shared/clock_lib2.c          |   3 +-
 platform/msm_shared/dev_tree.c            |  11 +-
 platform/msm_shared/display.c             |  12 ++
 platform/msm_shared/edp.c                 |   3 +
 platform/msm_shared/edp_aux.c             |   2 +
 platform/msm_shared/edp_phy.c             |   1 +
 platform/msm_shared/hsusb.c               |  16 +-
 platform/msm_shared/i2c_qup.c             |   4 +
 platform/msm_shared/interrupts.c          |   5 +
 platform/msm_shared/mdp5.c                |   7 +-
 platform/msm_shared/mipi_dsi.c            |  18 +-
 platform/msm_shared/mipi_dsi_autopll.c    |   3 +
 platform/msm_shared/mipi_dsi_phy.c        |   4 +
 platform/msm_shared/mmc_sdhci.c           |   4 +
 platform/msm_shared/mmc_wrapper.c         |   1 +
 platform/msm_shared/partition_parser.c    |  12 +-
 platform/msm_shared/qpic_nand.c           |   2 +-
 platform/msm_shared/reboot.c              |   2 +
 platform/msm_shared/scm.c                 |  21 +-
 platform/msm_shared/sdhci_msm.c           |   3 +-
 platform/msm_shared/shutdown_detect.c     |   6 +-
 platform/msm_shared/smem.c                |   6 +-
 platform/msm_shared/spmi.c                |  10 +-
 platform/msm_shared/usb30_dwc_hw.h        |   1 +
 platform/msm_shared/usb30_udc.c           |   2 +
 target/msm8226/init.c                     |   4 +
 target/msm8916/init.c                     |   4 +
 target/msm8974/init.c                     |   8 +
 56 files changed, 484 insertions(+), 90 deletions(-)
 create mode 100644 lib/libc/string/strtol.c

diff --git a/app/aboot/aboot.c b/app/aboot/aboot.c
index 0ad935bba..70f35de67 100644
--- a/app/aboot/aboot.c
+++ b/app/aboot/aboot.c
@@ -86,12 +86,16 @@
 #include "secapp_loader.h"
 #include <menu_keys_detect.h>
 #include <display_menu.h>
+#include <image_verify.h>
+#include <boot_verifier.h>
 
 extern  bool target_use_signed_kernel(void);
 extern void platform_uninit(void);
 extern void target_uninit(void);
 extern int get_target_boot_params(const char *cmdline, const char *part,
 				  char *buf, int buflen);
+extern void hash_find(unsigned char *addr, unsigned int size, unsigned char *digest, unsigned char auth_alg);
+extern void save_kernel_hash_cmd(void *digest);
 
 void *info_buf;
 void write_device_info_mmc(device_info *dev);
@@ -100,6 +104,10 @@ static int aboot_save_boot_hash_mmc(uint32_t image_addr, uint32_t image_size);
 extern void display_fbcon_message(char *str);
 static int aboot_frp_unlock(char *pname, void *data, unsigned sz);
 static inline uint64_t validate_partition_size();
+
+extern uint32_t read_der_message_length(unsigned char* input, unsigned sz);
+extern int image_verify(unsigned char *image_ptr, unsigned char *signature_ptr, unsigned int image_size, unsigned hash_type);
+
 bool pwr_key_is_pressed = false;
 unsigned boot_into_recovery = 0;
 unsigned bytes_to_round_page = 0;
@@ -320,7 +328,7 @@ static unsigned char *update_cmdline0(const char * cmdline)
 {
 	int cmdline_len = 0;
 	int have_cmdline = 0;
-	unsigned char *cmdline_final = NULL;
+	char *cmdline_final = NULL;
 	int pause_at_bootup = 0;
 	bool warm_boot = false;
 	bool gpt_exists = partition_gpt_exists();
@@ -452,7 +460,7 @@ static unsigned char *update_cmdline0(const char * cmdline)
 		const char *src;
 		unsigned char *dst;
 
-		cmdline_final = (unsigned char*) malloc((cmdline_len + 4) & (~3));
+		cmdline_final = (char*) malloc((cmdline_len + 4) & (~3));
 		ASSERT(cmdline_final != NULL);
 		memset((void *)cmdline_final, 0, sizeof(*cmdline_final));
 		dst = cmdline_final;
@@ -622,8 +630,9 @@ static unsigned char *update_cmdline0(const char * cmdline)
 		free(boot_dev_buf);
 
 	dprintf(INFO, "cmdline: %s\n", cmdline_final ? cmdline_final : "");
-	return cmdline_final;
+	return (unsigned char *)cmdline_final;
 }
+
 static char *concat_args(const char *a, const char *b)
 {
 	int lenA = strlen(a), lenB = strlen(b);
@@ -633,6 +642,7 @@ static char *concat_args(const char *a, const char *b)
 	memcpy(r + lenA + 1, b, lenB + 1);
 	return r;
 }
+
 unsigned char *update_cmdline(const char *cmdline)
 {
 #if WITH_LK2ND
@@ -817,7 +827,7 @@ void boot_linux(void *kernel, unsigned *tags,
 	uint32_t tags_phys = PA((addr_t)tags);
 	struct kernel64_hdr *kptr = (struct kernel64_hdr*)kernel;
 
-	ramdisk = PA(ramdisk);
+	ramdisk = (void *)PA((addr_t)ramdisk);
 
 	final_cmdline = update_cmdline((const char*)cmdline);
 
@@ -1934,7 +1944,7 @@ static int read_allow_oem_unlock(device_info *dev)
 	ptn_size = partition_get_size(index);
 	offset = ptn_size - blocksize;
 
-	if (mmc_read(ptn + offset, buf, sizeof(buf)))
+	if (mmc_read(ptn + offset, (uint32_t *)buf, sizeof(buf)))
 	{
 		dprintf(CRITICAL, "Reading MMC failed\n");
 		return -1;
@@ -1969,7 +1979,7 @@ static int write_allow_oem_unlock(bool allow_unlock)
 	ptn_size = partition_get_size(index);
 	offset = ptn_size - blocksize;
 
-	if (mmc_read(ptn + offset, buf, sizeof(buf)))
+	if (mmc_read(ptn + offset, (uint32_t *)buf, sizeof(buf)))
 	{
 		dprintf(CRITICAL, "Reading MMC failed\n");
 		return -1;
@@ -4139,7 +4149,7 @@ static int aboot_save_boot_hash_mmc(uint32_t image_addr, uint32_t image_size)
 #endif
 
 	target_crypto_init_params();
-	hash_find(image_addr, image_size, (unsigned char *)&digest, auth_algo);
+	hash_find((unsigned char *)image_addr, image_size, (unsigned char *)&digest, auth_algo);
 
 	save_kernel_hash_cmd(digest);
 	dprintf(INFO, "aboot_save_boot_hash_mmc: imagesize_actual size %d bytes.\n", (int) image_size);
diff --git a/app/aboot/fastboot.c b/app/aboot/fastboot.c
index 36e6dedac..bcf72fbf8 100644
--- a/app/aboot/fastboot.c
+++ b/app/aboot/fastboot.c
@@ -288,7 +288,7 @@ static int hsusb_usb_read(void *_buf, unsigned len)
 
 	while (len > 0) {
 		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
-		req->buf = PA((addr_t)buf);
+		req->buf = (void *)PA((addr_t)buf);
 		req->length = xfer;
 		req->complete = req_complete;
 		r = udc_request_queue(out, req);
@@ -314,7 +314,7 @@ static int hsusb_usb_read(void *_buf, unsigned len)
 	 * Force reload of buffer from memory
 	 * since transaction is complete now.
 	 */
-	arch_invalidate_cache_range(_buf, count);
+	arch_invalidate_cache_range((addr_t)_buf, count);
 	return count;
 
 oops:
@@ -334,7 +334,7 @@ static int hsusb_usb_write(void *buf, unsigned len)
 
 	while (len > 0) {
 		xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
-		req->buf = PA((addr_t)_buf);
+		req->buf = (void *)PA((addr_t)_buf);
 		req->length = xfer;
 		req->complete = req_complete;
 		r = udc_request_queue(in, req);
diff --git a/arch/arm/mmu.c b/arch/arm/mmu.c
index 3e086270d..5ee424986 100644
--- a/arch/arm/mmu.c
+++ b/arch/arm/mmu.c
@@ -26,8 +26,12 @@
 #include <arch.h>
 #include <arch/arm.h>
 #include <arch/defines.h>
+#include <arch/ops.h>
 #include <arch/arm/mmu.h>
 
+extern int platform_use_identity_mmu_mappings(void);
+extern void platform_init_mmu_mappings(void);
+
 #if ARM_WITH_MMU
 
 #define MB (1024*1024)
diff --git a/dev/gcdb/display/gcdb_display.c b/dev/gcdb/display/gcdb_display.c
index e263a5e81..505e9f967 100644
--- a/dev/gcdb/display/gcdb_display.c
+++ b/dev/gcdb/display/gcdb_display.c
@@ -36,7 +36,9 @@
 #include <board.h>
 #include <mdp5.h>
 #include <platform/gpio.h>
+#include <platform/timer.h>
 #include <mipi_dsi.h>
+#include <target.h>
 
 #include "include/display_resource.h"
 #include "include/panel.h"
@@ -45,6 +47,14 @@
 #include "target/display.h"
 #include "gcdb_autopll.h"
 
+extern uint8_t target_is_edp();
+extern void target_edp_panel_init(struct msm_panel_info *pinfo);
+extern int target_edp_panel_clock(uint8_t enable, struct msm_panel_info *pinfo);
+extern int target_edp_panel_enable(void);
+extern int target_edp_panel_disable(void);
+extern int target_edp_bl_ctrl(int enable);
+extern int oem_panel_select(const char *panel_name, struct panel_struct *panel, struct msm_panel_info *pinfo, struct mdss_dsi_phy_ctrl *phy_db);
+
 /*---------------------------------------------------------------------------*/
 /* static                                                                    */
 /*---------------------------------------------------------------------------*/
@@ -76,10 +86,9 @@ static uint32_t mdss_dsi_panel_reset(uint8_t enable)
 	return ret;
 }
 
-static uint32_t mdss_dsi_panel_clock(uint8_t enable,
-				struct msm_panel_info *pinfo)
+static int mdss_dsi_panel_clock(int enable, struct msm_panel_info *pinfo)
 {
-	uint32_t ret = NO_ERROR;
+	int ret = NO_ERROR;
 
 	ret = calculate_clock_config(pinfo);
 	if (ret) {
@@ -92,8 +101,7 @@ static uint32_t mdss_dsi_panel_clock(uint8_t enable,
 	return ret;
 }
 
-static int mdss_dsi_panel_power(uint8_t enable,
-				struct msm_panel_info *pinfo)
+static int mdss_dsi_panel_power(int enable, struct msm_panel_info *pinfo)
 {
 	int ret = NO_ERROR;
 
@@ -151,7 +159,7 @@ static int mdss_dsi_panel_pre_init(void)
 	return ret;
 }
 
-static int mdss_dsi_bl_enable(uint8_t enable)
+static int mdss_dsi_bl_enable(int enable)
 {
 	int ret = NO_ERROR;
 
@@ -302,13 +310,12 @@ static void init_platform_data()
 
 static void mdss_edp_panel_init(struct msm_panel_info *pinfo)
 {
-	return target_edp_panel_init(pinfo);
+	target_edp_panel_init(pinfo);
 }
 
-static uint32_t mdss_edp_panel_clock(uint8_t enable,
-				struct msm_panel_info *pinfo)
+static int mdss_edp_panel_clock(int enable)
 {
-	return target_edp_panel_clock(enable, pinfo);
+	return target_edp_panel_clock(enable, NULL);
 }
 
 static uint32_t mdss_edp_panel_enable(void)
@@ -321,8 +328,7 @@ static uint32_t mdss_edp_panel_disable(void)
 	return target_edp_panel_disable();
 }
 
-static int mdss_edp_panel_power(uint8_t enable,
-				struct msm_panel_info *pinfo)
+static int mdss_edp_panel_power(int enable, struct msm_panel_info *pinfo)
 {
 	int ret = NO_ERROR;
 
@@ -358,7 +364,7 @@ static int mdss_edp_panel_power(uint8_t enable,
 	return ret;
 }
 
-static int mdss_edp_bl_enable(uint8_t enable)
+static int mdss_edp_bl_enable(int enable)
 {
 	int ret = NO_ERROR;
 
diff --git a/dev/gcdb/display/panel_display.c b/dev/gcdb/display/panel_display.c
index c4291a58e..d3fefa1ad 100755
--- a/dev/gcdb/display/panel_display.c
+++ b/dev/gcdb/display/panel_display.c
@@ -47,6 +47,12 @@
 #include "panel_display.h"
 #include "include/panel.h"
 
+extern int target_display_pre_on();
+extern int target_display_pre_off();
+extern int target_display_post_on();
+extern int target_display_post_off();
+extern int mdss_dsi_cmd_mode_config(uint16_t disp_width, uint16_t disp_height, uint16_t img_width, uint16_t img_height, uint16_t dst_format, uint8_t ystride, uint8_t lane_en, uint8_t interleav, uint32_t ctl_base);
+
 /*---------------------------------------------------------------------------*/
 /* Panel Init                                                                */
 /*---------------------------------------------------------------------------*/
diff --git a/dev/pmic/pm8x41/pm8x41_vib.c b/dev/pmic/pm8x41/pm8x41_vib.c
index 7dbba773f..42dc3d3e4 100644
--- a/dev/pmic/pm8x41/pm8x41_vib.c
+++ b/dev/pmic/pm8x41/pm8x41_vib.c
@@ -30,6 +30,7 @@
 #include <debug.h>
 #include <reg.h>
 #include <pm8x41.h>
+#include <pm8x41_hw.h>
 #include <pm_vib.h>
 
 #define QPNP_VIB_EN    BIT(7)
diff --git a/dev/vib/vibrator.c b/dev/vib/vibrator.c
index e8cb8c7c3..2ea9bcf87 100644
--- a/dev/vib/vibrator.c
+++ b/dev/vib/vibrator.c
@@ -30,6 +30,7 @@
 #include <reg.h>
 #include <stdlib.h>
 #include <kernel/timer.h>
+#include <kernel/thread.h>
 #include <platform/timer.h>
 #include <vibrator.h>
 #include <pm_vib.h>
@@ -52,7 +53,7 @@ void vib_turn_off()
 }
 
 /* Function to turn off vibrator when the vib_timer is expired. */
-static enum handler_return vib_timer_func(struct timer *v_timer, void *arg)
+static enum handler_return vib_timer_func(struct timer *v_timer, long unsigned int arg0, void *arg1)
 {
 	timer_cancel(&vib_timer);
 	vib_turn_off();
diff --git a/include/string.h b/include/string.h
index f81562f8b..0d8607c09 100644
--- a/include/string.h
+++ b/include/string.h
@@ -59,6 +59,11 @@ size_t      strxfrm(char *dest, const char *src, size_t n) __PURE;
 char       *strdup(const char *str) __MALLOC;
 void        strrev(unsigned char *str);
 
+unsigned long long strtoull(const char *restrict s, char **restrict p, int base);
+long long strtoll(const char *restrict s, char **restrict p, int base);
+unsigned long strtoul(const char *restrict s, char **restrict p, int base);
+long strtol(const char *restrict s, char **restrict p, int base);
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
diff --git a/kernel/main.c b/kernel/main.c
index 95a433951..0e5a87b3b 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -34,6 +34,8 @@
 #include <kernel/timer.h>
 #include <kernel/dpc.h>
 #include <boot_stats.h>
+#include <lib/bio.h>
+#include <lib/fs.h>
 
 extern void *__ctor_list;
 extern void *__ctor_end;
diff --git a/lib/debug/debug.c b/lib/debug/debug.c
index c6611835a..36c195ff9 100644
--- a/lib/debug/debug.c
+++ b/lib/debug/debug.c
@@ -36,8 +36,7 @@
 #include <kernel/timer.h>
 #include <rand.h>
 
-void __attribute__ ((noreturn))
-__stack_chk_fail (void)
+void __attribute__ ((noreturn)) __stack_chk_fail (void)
 {
 	panic("stack smashing detected.");
 }
@@ -50,13 +49,13 @@ void spin(uint32_t usecs)
 		;	
 }
 
-void halt(void)
+void __attribute__ ((noreturn)) halt(void)
 {
 	enter_critical_section(); // disable ints
 	platform_halt();
 }
 
-void _panic(void *caller, const char *fmt, ...)
+void __attribute__ ((noreturn)) _panic(void *caller, const char *fmt, ...)
 {
 	dprintf(ALWAYS, "panic (caller %p): ", caller);
 
diff --git a/lib/fs/ext2/dir.c b/lib/fs/ext2/dir.c
index 90dc42584..1ecc53413 100644
--- a/lib/fs/ext2/dir.c
+++ b/lib/fs/ext2/dir.c
@@ -225,7 +225,7 @@ status_t ext2_open_directory(fscookie *cookie, const char *path, dircookie **dir
 	dir->offset = 0;
 	dir->length = entry_len;
 
-	*dircookie = dir;
+	*dircookie = (struct dircookie *)dir;
 
 	return 0;
 }
@@ -254,7 +254,7 @@ status_t ext2_read_directory(dircookie *dircookie, struct dirent *ent) {
 status_t ext2_close_directory(dircookie *dircookie) {
 	ext2_dir_t *dir = (ext2_dir_t *)dircookie;
 
-	ext2_close_file(dir->file);
+	ext2_close_file((filecookie *)dir->file);
 	free(dir);
 	return 0;
 }
diff --git a/lib/libc/string/rules.mk b/lib/libc/string/rules.mk
index dd594d5fa..25a66e7f1 100644
--- a/lib/libc/string/rules.mk
+++ b/lib/libc/string/rules.mk
@@ -30,6 +30,7 @@ C_STRING_OPS := \
 	strspn \
 	strstr \
 	strtok \
+	strtol \
 	strxfrm
 
 LIBC_STRING_C_DIR := $(LOCAL_DIR)
diff --git a/lib/libc/string/strtol.c b/lib/libc/string/strtol.c
new file mode 100644
index 000000000..5e984401b
--- /dev/null
+++ b/lib/libc/string/strtol.c
@@ -0,0 +1,242 @@
+#include <sys/types.h>
+
+/* The shcnt field stores the number of bytes read so far, offset by
+ * the value of buf-rpos at the last function call (__shlim or __shgetc),
+ * so that between calls the inline shcnt macro can add rpos-buf to get
+ * the actual count. */
+
+/* This function assumes it will never be called if there is already
+ * data buffered for reading. */
+
+#define EOF (-1)
+
+#define FFINALLOCK(f) ((f)->lock>=0 ? __lockfile((f)) : 0)
+#define FLOCK(f) int __need_unlock = ((f)->lock>=0 ? __lockfile((f)) : 0)
+#define FUNLOCK(f) do { if (__need_unlock) __unlockfile((f)); } while (0)
+
+#define F_PERM 1
+#define F_NORD 4
+#define F_NOWR 8
+#define F_EOF 16
+#define F_ERR 32
+#define F_SVB 64
+#define F_APP 128
+
+typedef struct _IO_FILE FILE;
+
+struct _IO_FILE {
+	unsigned flags;
+	unsigned char *rpos, *rend;
+	int (*close)(FILE *);
+	unsigned char *wend, *wpos;
+	unsigned char *mustbezero_1;
+	unsigned char *wbase;
+	size_t (*read)(FILE *, unsigned char *, size_t);
+	size_t (*write)(FILE *, const unsigned char *, size_t);
+	off_t (*seek)(FILE *, off_t, int);
+	unsigned char *buf;
+	size_t buf_size;
+	FILE *prev, *next;
+	int fd;
+	int pipe_pid;
+	long lockcount;
+	int mode;
+	volatile int lock;
+	int lbf;
+	void *cookie;
+	off_t off;
+	char *getln_buf;
+	void *mustbezero_2;
+	unsigned char *shend;
+	off_t shlim, shcnt;
+	FILE *prev_locked, *next_locked;
+	struct __locale_struct *locale;
+};
+
+static int __toread(FILE *f)
+{
+	f->mode |= f->mode-1;
+	if (f->wpos != f->wbase) f->write(f, 0, 0);
+	f->wpos = f->wbase = f->wend = 0;
+	if (f->flags & F_NORD) {
+		f->flags |= F_ERR;
+		return EOF;
+	}
+	f->rpos = f->rend = f->buf + f->buf_size;
+	return (f->flags & F_EOF) ? EOF : 0;
+}
+
+static int __uflow(FILE *f)
+{
+	unsigned char c;
+	if (!__toread(f) && f->read(f, &c, 1)==1) return c;
+	return EOF;
+}
+
+#define shcnt(f) ((f)->shcnt + ((f)->rpos - (f)->buf))
+#define shlim(f, lim) __shlim((f), (lim))
+#define shgetc(f) (((f)->rpos != (f)->shend) ? *(f)->rpos++ : __shgetc(f))
+#define shunget(f) ((f)->shlim>=0 ? (void)(f)->rpos-- : (void)0)
+
+#define sh_fromstring(f, s) \
+	((f)->buf = (f)->rpos = (void *)(s), (f)->rend = (void*)-1)
+
+static void __shlim(FILE *f, off_t lim)
+{
+	f->shlim = lim;
+	f->shcnt = f->buf - f->rpos;
+	/* If lim is nonzero, rend must be a valid pointer. */
+	if (lim && f->rend - f->rpos > lim)
+		f->shend = f->rpos + lim;
+	else
+		f->shend = f->rend;
+}
+
+static int __shgetc(FILE *f)
+{
+	int c;
+	off_t cnt = shcnt(f);
+	if (f->shlim && cnt >= f->shlim || (c=__uflow(f)) < 0) {
+		f->shcnt = f->buf - f->rpos + cnt;
+		f->shend = f->rpos;
+		f->shlim = -1;
+		return EOF;
+	}
+	cnt++;
+	if (f->shlim && f->rend - f->rpos > f->shlim - cnt)
+		f->shend = f->rpos + (f->shlim - cnt);
+	else
+		f->shend = f->rend;
+	f->shcnt = f->buf - f->rpos + cnt;
+	if (f->rpos <= f->buf) f->rpos[-1] = c;
+	return c;
+}
+
+static int isspace(int c)
+{
+	return c == ' ' || (unsigned)c-'\t' < 5;
+}
+
+/* Lookup table for digit values. -1==255>=36 -> invalid */
+static const unsigned char table[] = { -1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
+-1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
+25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
+-1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
+25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
+};
+
+static unsigned long long __intscan(FILE *f, unsigned base, int pok, unsigned long long lim)
+{
+	const unsigned char *val = table+1;
+	int c, neg=0;
+	unsigned x;
+	unsigned long long y;
+	if (base > 36 || base == 1) {
+		return 0;
+	}
+	while (isspace((c=shgetc(f))));
+	if (c=='+' || c=='-') {
+		neg = -(c=='-');
+		c = shgetc(f);
+	}
+	if ((base == 0 || base == 16) && c=='0') {
+		c = shgetc(f);
+		if ((c|32)=='x') {
+			c = shgetc(f);
+			if (val[c]>=16) {
+				shunget(f);
+				if (pok) shunget(f);
+				else shlim(f, 0);
+				return 0;
+			}
+			base = 16;
+		} else if (base == 0) {
+			base = 8;
+		}
+	} else {
+		if (base == 0) base = 10;
+		if (val[c] >= base) {
+			shunget(f);
+			shlim(f, 0);
+			return 0;
+		}
+	}
+	if (base == 10) {
+		for (x=0; c-'0'<10U && x<=UINT_MAX/10-1; c=shgetc(f))
+			x = x*10 + (c-'0');
+		for (y=x; c-'0'<10U && y<=ULLONG_MAX/10 && 10*y<=ULLONG_MAX-(c-'0'); c=shgetc(f))
+			y = y*10 + (c-'0');
+		if (c-'0'>=10U) goto done;
+	} else if (!(base & base-1)) {
+		int bs = "\0\1\2\4\7\3\6\5"[(0x17*base)>>5&7];
+		for (x=0; val[c]<base && x<=UINT_MAX/32; c=shgetc(f))
+			x = x<<bs | val[c];
+		for (y=x; val[c]<base && y<=ULLONG_MAX>>bs; c=shgetc(f))
+			y = y<<bs | val[c];
+	} else {
+		for (x=0; val[c]<base && x<=UINT_MAX/36-1; c=shgetc(f))
+			x = x*base + val[c];
+		for (y=x; val[c]<base && y<=ULLONG_MAX/base && base*y<=ULLONG_MAX-val[c]; c=shgetc(f))
+			y = y*base + val[c];
+	}
+	if (val[c]<base) {
+		for (; val[c]<base; c=shgetc(f));
+		y = lim;
+		if (lim&1) neg = 0;
+	}
+done:
+	shunget(f);
+	if (y>=lim) {
+		if (!(lim&1) && !neg) {
+			return lim-1;
+		} else if (y>lim) {
+			return lim;
+		}
+	}
+	return (y^neg)-neg;
+}
+
+static unsigned long long strtox(const char *s, char **p, int base, unsigned long long lim)
+{
+	FILE f;
+	sh_fromstring(&f, s);
+	shlim(&f, 0);
+	unsigned long long y = __intscan(&f, base, 1, lim);
+	if (p) {
+		size_t cnt = shcnt(&f);
+		*p = (char *)s + cnt;
+	}
+	return y;
+}
+
+unsigned long long strtoull(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, ULLONG_MAX);
+}
+
+long long strtoll(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, LLONG_MIN);
+}
+
+unsigned long strtoul(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, ULONG_MAX);
+}
+
+long strtol(const char *restrict s, char **restrict p, int base)
+{
+	return strtox(s, p, base, 0UL+LONG_MIN);
+}
diff --git a/lib/libfdt/fdt_overlay.c b/lib/libfdt/fdt_overlay.c
index d217e79b6..e05365a54 100644
--- a/lib/libfdt/fdt_overlay.c
+++ b/lib/libfdt/fdt_overlay.c
@@ -476,7 +476,7 @@ static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
 		if (!name_len)
 			return -FDT_ERR_BADOVERLAY;
 
-		poffset = strtoul(sep + 1, &endptr, 10);
+		poffset = strtol(sep + 1, &endptr, 10);
 		if ((*endptr != '\0') || (endptr <= (sep + 1)))
 			return -FDT_ERR_BADOVERLAY;
 
diff --git a/platform/init.c b/platform/init.c
index 78a5c02d3..0b7bace61 100644
--- a/platform/init.c
+++ b/platform/init.c
@@ -103,7 +103,7 @@ __WEAK void ce_clock_init(void)
 
 __WEAK addr_t get_bs_info_addr()
 {
-	return NULL;
+	return 0;
 }
 
 __WEAK uint32_t platform_get_sclk_count(void)
diff --git a/platform/msm8226/include/platform/iomap.h b/platform/msm8226/include/platform/iomap.h
index 289a2cceb..ff54dc5f0 100644
--- a/platform/msm8226/include/platform/iomap.h
+++ b/platform/msm8226/include/platform/iomap.h
@@ -191,6 +191,9 @@
 #define MDP_VP_0_MIXER_0_BASE        REG_MDP(0x3200)
 #define MDP_VP_0_MIXER_1_BASE        REG_MDP(0x3600)
 
+#define DSIPHY_PLL_BASE             (0x200)
+#define DSIPHY_PLL_CTRL(x)           REG_DSI(DSIPHY_PLL_BASE + (x) * 4)
+
 #define SOFT_RESET                  0x118
 #define CLK_CTRL                    0x11C
 #define TRIG_CTRL                   0x084
diff --git a/platform/msm8226/msm8226-clock.c b/platform/msm8226/msm8226-clock.c
index d79b8953d..0ef1c5cd9 100644
--- a/platform/msm8226/msm8226-clock.c
+++ b/platform/msm8226/msm8226-clock.c
@@ -501,7 +501,7 @@ static struct branch_clk mdss_mdp_clk = {
 };
 
 static struct branch_clk mdss_mdp_lut_clk = {
-	.cbcr_reg    = MDP_LUT_CBCR,
+	.cbcr_reg    = (uint32_t *) MDP_LUT_CBCR,
 	.parent      = &mdss_mdp_clk_src.c,
 	.has_sibling = 1,
 
@@ -512,7 +512,7 @@ static struct branch_clk mdss_mdp_lut_clk = {
 };
 
 static struct branch_clk mdss_vsync_clk = {
-	.cbcr_reg    = MDSS_VSYNC_CBCR,
+	.cbcr_reg    = (uint32_t *) MDSS_VSYNC_CBCR,
 	.parent      = &vsync_clk_src.c,
 	.has_sibling = 0,
 
diff --git a/platform/msm8226/platform.c b/platform/msm8226/platform.c
index 1d15a626d..887e3b075 100644
--- a/platform/msm8226/platform.c
+++ b/platform/msm8226/platform.c
@@ -37,6 +37,7 @@
 #include <smem.h>
 #include <board.h>
 #include <boot_stats.h>
+#include <platform.h>
 
 #define MB (1024*1024)
 
diff --git a/platform/msm8916/acpuclock.c b/platform/msm8916/acpuclock.c
index 73d18a351..0317d5cc4 100644
--- a/platform/msm8916/acpuclock.c
+++ b/platform/msm8916/acpuclock.c
@@ -193,6 +193,9 @@ void mdp_gdsc_ctrl(uint8_t enable)
 	}
 }
 
+int platform_is_msm8939();
+int platform_is_msm8929();
+
 /* Enable all the MDP branch clocks */
 void mdp_clock_enable(void)
 {
diff --git a/platform/msm8916/include/platform/iomap.h b/platform/msm8916/include/platform/iomap.h
index 5e23a2528..25149188c 100644
--- a/platform/msm8916/include/platform/iomap.h
+++ b/platform/msm8916/include/platform/iomap.h
@@ -91,6 +91,11 @@
 #define TLMM_BASE_ADDR              0x1000000
 #define GPIO_CONFIG_ADDR(x)         (TLMM_BASE_ADDR + (x)*0x1000)
 #define GPIO_IN_OUT_ADDR(x)         (TLMM_BASE_ADDR + 0x00000004 + (x)*0x1000)
+#define GPIO_OUT_SET_ADDR(x)        (TLMM_BASE_ADDR + 0x3040 + (x/32)*0x04)
+#define GPIO_OUT_CLR_ADDR(x)        (TLMM_BASE_ADDR + 0x3020 + (x/32)*0x04)
+#define GPIO_OUT_OE_SET_ADDR(x)     (TLMM_BASE_ADDR + 0x3120 + (x/32)*0x04)
+#define GPIO_OUT_VAL(x)             (1 << (x - (x/32)*32))
+#define GPIO_OUT_OE_VAL(x)          (1 << (x - (x/32)*32))
 
 #define MPM2_MPM_CTRL_BASE          0x004A0000
 #define MPM2_MPM_PS_HOLD            0x004AB000
@@ -206,6 +211,9 @@
 #define REG_DSI(off)                (MIPI_DSI_BASE + 0x04 + (off))
 #define MDP_BASE                    (0x1A00000)
 #define REG_MDP(off)                (MDP_BASE + (off))
+#define DSIPHY_PLL_BASE             (0x200)
+#define DSIPHY_PLL_CTRL(x)          REG_DSI(DSIPHY_PLL_BASE + (x) * 4)
+
 #define MDP_HW_REV                              REG_MDP(0x1000)
 #define MDP_VP_0_VIG_0_BASE                     REG_MDP(0x5000)
 #define MDP_VP_0_VIG_1_BASE                     REG_MDP(0x7000)
diff --git a/platform/msm8916/msm8916-clock.c b/platform/msm8916/msm8916-clock.c
index 86df72211..f70cb4ecb 100644
--- a/platform/msm8916/msm8916-clock.c
+++ b/platform/msm8916/msm8916-clock.c
@@ -34,6 +34,7 @@
 #include <clock_lib2.h>
 #include <platform/clock.h>
 #include <platform/iomap.h>
+#include <platform/timer.h>
 
 
 /* Mux source select values */
@@ -506,7 +507,7 @@ static struct branch_clk mdss_mdp_clk = {
 };
 
 static struct branch_clk mdss_vsync_clk = {
-	.cbcr_reg    = MDSS_VSYNC_CBCR,
+	.cbcr_reg    = (uint32_t *)MDSS_VSYNC_CBCR,
 	.parent      = &vsync_clk_src.c,
 	.has_sibling = 0,
 
@@ -606,7 +607,7 @@ static struct rcg_clk gcc_blsp1_qup2_i2c_apps_clk_src =
 };
 
 static struct branch_clk gcc_blsp1_qup2_i2c_apps_clk = {
-	.cbcr_reg = GCC_BLSP1_QUP2_APPS_CBCR,
+	.cbcr_reg = (uint32_t *)GCC_BLSP1_QUP2_APPS_CBCR,
 	.parent   = &gcc_blsp1_qup2_i2c_apps_clk_src.c,
 
 	.c = {
@@ -807,6 +808,9 @@ void msm8939_clock_override()
 	mdss_mdp_clk_src.freq_tbl = ftbl_mdss_mdp_clk_src;
 }
 
+int platform_is_msm8939();
+int platform_is_msm8929();
+
 void platform_clock_init(void)
 {
 	if (platform_is_msm8939() || platform_is_msm8929()) {
diff --git a/platform/msm8916/platform.c b/platform/msm8916/platform.c
index 103d099f4..621369b79 100644
--- a/platform/msm8916/platform.c
+++ b/platform/msm8916/platform.c
@@ -76,6 +76,7 @@ static mmu_section_t mmu_section_table[] = {
 
 int platform_is_msm8939();
 int platform_is_msm8929();
+void platform_clock_init();
 
 void platform_early_init(void)
 {
diff --git a/platform/msm8974/acpuclock.c b/platform/msm8974/acpuclock.c
index 730147d8c..55b253048 100644
--- a/platform/msm8974/acpuclock.c
+++ b/platform/msm8974/acpuclock.c
@@ -38,6 +38,10 @@
 #include <blsp_qup.h>
 #include <pm8x41.h>
 
+extern int platform_is_8974();
+extern int platform_is_8974ac();
+extern int platform_is_8974Pro();
+
 void hsusb_clock_init(void)
 {
 	int ret;
diff --git a/platform/msm8974/include/platform/iomap.h b/platform/msm8974/include/platform/iomap.h
index 7490cabd8..4821d82b5 100644
--- a/platform/msm8974/include/platform/iomap.h
+++ b/platform/msm8974/include/platform/iomap.h
@@ -238,6 +238,9 @@
 #define MDP_VP_0_MIXER_0_BASE        REG_MDP(0x3200)
 #define MDP_VP_0_MIXER_1_BASE        REG_MDP(0x3600)
 
+#define DSIPHY_PLL_BASE             (0x200)
+#define DSIPHY_PLL_CTRL(x)           REG_DSI(DSIPHY_PLL_BASE + (x) * 4)
+
 #define SOFT_RESET                  0x118
 #define CLK_CTRL                    0x11C
 #define TRIG_CTRL                   0x084
diff --git a/platform/msm8974/msm8974-clock.c b/platform/msm8974/msm8974-clock.c
index 8f3dadf7e..e1c69a831 100644
--- a/platform/msm8974/msm8974-clock.c
+++ b/platform/msm8974/msm8974-clock.c
@@ -35,6 +35,10 @@
 #include <platform/clock.h>
 #include <platform/iomap.h>
 
+extern int platform_is_8974();
+extern int platform_is_8974ac();
+extern int platform_is_8974Pro();
+
 
 /* Mux source select values */
 #define cxo_source_val    0
@@ -204,7 +208,7 @@ static struct branch_clk gcc_sdcc1_ahb_clk =
 
 static struct branch_clk gcc_sdcc1_cdccal_sleep_clk =
 {
-	.cbcr_reg = SDCC1_CDCCAL_SLEEP_CBCR,
+	.cbcr_reg = (uint32_t *) SDCC1_CDCCAL_SLEEP_CBCR,
 	.has_sibling = 1,
 
 	.c = {
@@ -215,7 +219,7 @@ static struct branch_clk gcc_sdcc1_cdccal_sleep_clk =
 
 static struct branch_clk gcc_sdcc1_cdccal_ff_clk =
 {
-	.cbcr_reg = SDCC1_CDCCAL_FF_CBCR,
+	.cbcr_reg = (uint32_t *) SDCC1_CDCCAL_FF_CBCR,
 	.has_sibling = 1,
 
 	.c = {
@@ -486,7 +490,7 @@ static struct vote_clk gcc_ce1_axi_clk = {
 
 
 struct branch_clk gcc_blsp2_qup5_i2c_apps_clk = {
-	.cbcr_reg = BLSP2_QUP5_I2C_APPS_CBCR,
+	.cbcr_reg = (uint32_t *) BLSP2_QUP5_I2C_APPS_CBCR,
 	.parent   = &cxo_clk_src.c,
 
 	.c = {
@@ -661,7 +665,7 @@ static struct branch_clk mdss_mdp_clk = {
 };
 
 static struct branch_clk mdss_mdp_lut_clk = {
-	.cbcr_reg    = MDP_LUT_CBCR,
+	.cbcr_reg    = (uint32_t *) MDP_LUT_CBCR,
 	.parent      = &mdss_mdp_clk_src.c,
 	.has_sibling = 1,
 
@@ -672,7 +676,7 @@ static struct branch_clk mdss_mdp_lut_clk = {
 };
 
 static struct branch_clk mdss_vsync_clk = {
-	.cbcr_reg    = MDSS_VSYNC_CBCR,
+	.cbcr_reg    = (uint32_t *) MDSS_VSYNC_CBCR,
 	.parent      = &vsync_clk_src.c,
 	.has_sibling = 0,
 
@@ -699,7 +703,7 @@ static struct rcg_clk edpaux_clk_src = {
 };
 
 static struct branch_clk mdss_edpaux_clk = {
-	.cbcr_reg    = MDSS_EDPAUX_CBCR,
+	.cbcr_reg    = (uint32_t *) MDSS_EDPAUX_CBCR,
 	.parent      = &edpaux_clk_src.c,
 	.has_sibling = 0,
 
diff --git a/platform/msm8974/platform.c b/platform/msm8974/platform.c
index a8d4ea4d9..8bdf5be6d 100644
--- a/platform/msm8974/platform.c
+++ b/platform/msm8974/platform.c
@@ -37,6 +37,7 @@
 #include <smem.h>
 #include <board.h>
 #include <boot_stats.h>
+#include <platform.h>
 
 #define MB (1024*1024)
 
diff --git a/platform/msm_shared/board.c b/platform/msm_shared/board.c
index 2d94750b4..cb06e3ce2 100644
--- a/platform/msm_shared/board.c
+++ b/platform/msm_shared/board.c
@@ -31,6 +31,8 @@
 #include <board.h>
 #include <smem.h>
 #include <baseband.h>
+#include <boot_device.h>
+#include <platform.h>
 
 struct board_data board = {UNKNOWN,
 	0,
diff --git a/platform/msm_shared/boot_stats.c b/platform/msm_shared/boot_stats.c
index 551000e95..be66a94b2 100644
--- a/platform/msm_shared/boot_stats.c
+++ b/platform/msm_shared/boot_stats.c
@@ -31,7 +31,11 @@
 #include <reg.h>
 #include <platform/iomap.h>
 
+extern addr_t get_bs_info_addr();
+extern uint32_t platform_get_sclk_count();
+
 static uint32_t kernel_load_start;
+
 void bs_set_timestamp(enum bs_entry bs_id)
 {
 	addr_t bs_imem = get_bs_info_addr();
diff --git a/platform/msm_shared/clock_lib2.c b/platform/msm_shared/clock_lib2.c
index f5e321a4b..7d7fbce5a 100644
--- a/platform/msm_shared/clock_lib2.c
+++ b/platform/msm_shared/clock_lib2.c
@@ -25,6 +25,7 @@
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+#include "stdint.h"
 #include <arch/defines.h>
 #include <assert.h>
 #include <reg.h>
@@ -270,5 +271,5 @@ int clock_lib2_branch_clk_reset(struct clk *c, enum clk_reset_action action)
 	if (!bclk)
 		return 0;
 
-	return __clock_lib2_branch_clk_reset(bclk->bcr_reg, action);
+	return __clock_lib2_branch_clk_reset((uint32_t)bclk->bcr_reg, action);
 }
diff --git a/platform/msm_shared/dev_tree.c b/platform/msm_shared/dev_tree.c
index 2d2174b98..e996e9665 100755
--- a/platform/msm_shared/dev_tree.c
+++ b/platform/msm_shared/dev_tree.c
@@ -37,6 +37,7 @@
 #include <board.h>
 #include <list.h>
 #include <kernel/thread.h>
+#include <target.h>
 #include <lk2nd.h>
 
 struct dt_entry_v1
@@ -555,7 +556,7 @@ void *dev_tree_appended(void *kernel, uint32_t kernel_size, uint32_t dtb_offset,
 	}
 	/* free queue's memory */
 	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
-		dt_node_tmp2 = dt_node_tmp1->node.prev;
+		dt_node_tmp2 = (struct dt_entry_node *)dt_node_tmp1->node.prev;
 		dt_entry_list_delete(dt_node_tmp1);
 		dt_node_tmp1 = dt_node_tmp2;
 	}
@@ -806,7 +807,7 @@ static int platform_dt_absolute_compat_match(struct dt_entry_node *dt_list, uint
 				dt_node_tmp1->dt_entry_m->pmic_rev[2], dt_node_tmp1->dt_entry_m->pmic_rev[3],
 				dt_node_tmp1->dt_entry_m->offset, dt_node_tmp1->dt_entry_m->size);
 
-			dt_node_tmp2 = dt_node_tmp1->node.prev;
+			dt_node_tmp2 = (struct dt_entry_node *)dt_node_tmp1->node.prev;
 			dt_entry_list_delete(dt_node_tmp1);
 			dt_node_tmp1 = dt_node_tmp2;
 			delete_current_dt = 0;
@@ -880,7 +881,7 @@ static int update_dtb_entry_node(struct dt_entry_node *dt_list, uint32_t dtb_inf
 				dt_node_tmp1->dt_entry_m->pmic_rev[2], dt_node_tmp1->dt_entry_m->pmic_rev[3],
 				dt_node_tmp1->dt_entry_m->offset, dt_node_tmp1->dt_entry_m->size);
 
-			dt_node_tmp2 = dt_node_tmp1->node.prev;
+			dt_node_tmp2 = (struct dt_entry_node *)dt_node_tmp1->node.prev;
 			dt_entry_list_delete(dt_node_tmp1);
 			dt_node_tmp1 = dt_node_tmp2;
 		}
@@ -924,7 +925,7 @@ static int update_dtb_entry_node(struct dt_entry_node *dt_list, uint32_t dtb_inf
 				dt_node_tmp1->dt_entry_m->pmic_rev[2], dt_node_tmp1->dt_entry_m->pmic_rev[3],
 				dt_node_tmp1->dt_entry_m->offset, dt_node_tmp1->dt_entry_m->size);
 
-			dt_node_tmp2 = dt_node_tmp1->node.prev;
+			dt_node_tmp2 = (struct dt_entry_node *)dt_node_tmp1->node.prev;
 			dt_entry_list_delete(dt_node_tmp1);
 			dt_node_tmp1 = dt_node_tmp2;
 		}
@@ -1149,7 +1150,7 @@ int dev_tree_get_entry_info(struct dt_table *table, struct dt_entry *dt_entry_in
 
 	list_for_every_entry(&dt_entry_queue->node, dt_node_tmp1, dt_node, node) {
 		/* free node memory */
-		dt_node_tmp2 = dt_node_tmp1->node.prev;
+		dt_node_tmp2 = (struct dt_entry_node *)dt_node_tmp1->node.prev;
 		dt_entry_list_delete(dt_node_tmp1);
 		dt_node_tmp1 = dt_node_tmp2;
 	}
diff --git a/platform/msm_shared/display.c b/platform/msm_shared/display.c
index 91d8ba19a..d43725372 100644
--- a/platform/msm_shared/display.c
+++ b/platform/msm_shared/display.c
@@ -30,12 +30,24 @@
 #include <err.h>
 #include <msm_panel.h>
 #include <mdp4.h>
+#include <mdp5.h>
 #include <mipi_dsi.h>
 #include <boot_stats.h>
+#include <malloc.h>
+#include <platform.h>
+#include <target.h>
 
 static struct msm_fb_panel_data *panel;
 
 extern int lvds_on(struct msm_fb_panel_data *pdata);
+extern int mdp_dsi_cmd_config(struct msm_panel_info *pinfo, struct fbcon_config *fb);
+extern int mdss_hdmi_config(struct msm_panel_info *pinfo, struct fbcon_config *fb);
+extern int mdss_dsi_post_on(struct msm_fb_panel_data *panel);
+extern int mdp_dma_on(struct msm_panel_info *pinfo);
+extern int mipi_cmd_trigger();
+extern int mdss_hdmi_on();
+extern int mdss_hdmi_init();
+extern int mdp_dsi_cmd_off();
 
 static int msm_fb_alloc(struct fbcon_config *fb)
 {
diff --git a/platform/msm_shared/edp.c b/platform/msm_shared/edp.c
index 017326291..8a5ba0e39 100644
--- a/platform/msm_shared/edp.c
+++ b/platform/msm_shared/edp.c
@@ -30,6 +30,9 @@
 #include "edp.h"
 #include "mdp5.h"
 
+extern void edp_phy_vm_pe_init(void);
+extern void edp_aux_enable(void);
+
 #define RGB_COMPONENTS		3
 #define MAX_NUMBER_EDP_LANES	4
 
diff --git a/platform/msm_shared/edp_aux.c b/platform/msm_shared/edp_aux.c
index 3cda4bb3f..9702f28f1 100644
--- a/platform/msm_shared/edp_aux.c
+++ b/platform/msm_shared/edp_aux.c
@@ -29,6 +29,8 @@
 
 #include "edp.h"
 
+extern void edp_isr_poll(void);
+
 struct edp_aux_ctrl edpctrl;
 
 int edp_hpd_done = 0;
diff --git a/platform/msm_shared/edp_phy.c b/platform/msm_shared/edp_phy.c
index b36c4522a..6d68757f5 100644
--- a/platform/msm_shared/edp_phy.c
+++ b/platform/msm_shared/edp_phy.c
@@ -27,6 +27,7 @@
  * SUCH DAMAGE.
  */
 #include "edp.h"
+#include <arch/defines.h>
 
 /* EDP phy configuration settings */
 
diff --git a/platform/msm_shared/hsusb.c b/platform/msm_shared/hsusb.c
index faf57d996..abcef3ffa 100644
--- a/platform/msm_shared/hsusb.c
+++ b/platform/msm_shared/hsusb.c
@@ -321,12 +321,12 @@ int udc_request_queue(struct udc_endpoint *ept, struct udc_request *_req)
 				return -1;
 			} else {
 				count ++;
-				curr_item->next = PA(item);
+				curr_item->next = (unsigned)PA((unsigned)item);
 				item->next = TERMINATE;
 			}
 		} else
 			/* Since next TD in chain already exists */
-			item = VA(curr_item->next);
+			item = (struct ept_queue_item *)VA(curr_item->next);
 
 		/* Update TD with transfer information */
 		item->info = INFO_BYTES(xfer) | INFO_ACTIVE;
@@ -345,7 +345,7 @@ int udc_request_queue(struct udc_endpoint *ept, struct udc_request *_req)
 	curr_item->next = TERMINATE;
 	curr_item->info |= INFO_IOC;
 	enter_critical_section();
-	ept->head->next = PA(req->item);
+	ept->head->next = (unsigned)PA((unsigned)req->item);
 	ept->head->info = 0;
 	ept->req = req;
 	arch_clean_invalidate_cache_range((addr_t) ept,
@@ -354,7 +354,7 @@ int udc_request_queue(struct udc_endpoint *ept, struct udc_request *_req)
 					  sizeof(struct ept_queue_head));
 	arch_clean_invalidate_cache_range((addr_t) ept->req,
 					  sizeof(struct usb_request));
-	arch_clean_invalidate_cache_range((addr_t) VA(req->req.buf),
+	arch_clean_invalidate_cache_range((addr_t) VA((unsigned)req->req.buf),
 					  req->req.length);
 
 	item = req->item;
@@ -364,7 +364,7 @@ int udc_request_queue(struct udc_endpoint *ept, struct udc_request *_req)
 		if (curr_item->next == TERMINATE)
 			item = NULL;
 		else
-			item = curr_item->next;
+			item = (struct ept_queue_item *)curr_item->next;
 		arch_clean_invalidate_cache_range((addr_t) curr_item,
 					  sizeof(struct ept_queue_item));
 	}
@@ -391,13 +391,13 @@ static void handle_ept_complete(struct udc_endpoint *ept)
 
 	if(ept->req)
 	{
-		req = VA(ept->req);
+		req = (struct usb_request *)VA((addr_t)ept->req);
 		arch_invalidate_cache_range((addr_t) ept->req,
 						sizeof(struct usb_request));
 	}
 
 	if (req) {
-		item = VA(req->item);
+		item = (struct ept_queue_item *)VA((addr_t)req->item);
 		/* total transfer length for transacation */
 		total_len = req->req.length;
 		ept->req = 0;
@@ -445,7 +445,7 @@ static void handle_ept_complete(struct udc_endpoint *ept)
 				actual += MAX_TD_XFER_SIZE - (item->info >> 16) & 0x7FFF;
 				total_len -= MAX_TD_XFER_SIZE - (item->info >> 16) & 0x7FFF;
 				/*Move to next item in chain*/
-				item = VA(item->next);
+				item = (struct ept_queue_item *)VA(item->next);
 			}
 		}
 		status = 0;
diff --git a/platform/msm_shared/i2c_qup.c b/platform/msm_shared/i2c_qup.c
index 15b4bac04..0fe45092b 100644
--- a/platform/msm_shared/i2c_qup.c
+++ b/platform/msm_shared/i2c_qup.c
@@ -48,6 +48,8 @@
 #include <platform/timer.h>
 #include <platform/interrupts.h>
 
+extern void clock_config_blsp_i2c(uint8_t blsp_id, uint8_t qup_id);
+
 #if DEBUGLEVEL > INFO
 #undef DEBUGLEVEL
 #define DEBUGLEVEL INFO
@@ -707,6 +709,7 @@ void qup_i2c_sec_init(struct qup_i2c_dev *dev, uint32_t clk_freq,
 	mask_interrupt(dev->qup_irq);
 }
 
+#ifdef GSBI_QUP_IRQ /* qup_i2c_init is used only for msm8x60 */
 struct qup_i2c_dev *qup_i2c_init(uint8_t gsbi_id, unsigned clk_freq,
 				 unsigned src_clk_freq)
 {
@@ -744,6 +747,7 @@ struct qup_i2c_dev *qup_i2c_init(uint8_t gsbi_id, unsigned clk_freq,
 
 	return dev;
 }
+#endif
 
 struct qup_i2c_dev *qup_blsp_i2c_init(uint8_t blsp_id, uint8_t qup_id,
 									  uint32_t clk_freq, uint32_t src_clk_freq)
diff --git a/platform/msm_shared/interrupts.c b/platform/msm_shared/interrupts.c
index 9d84bb264..15b0a604b 100644
--- a/platform/msm_shared/interrupts.c
+++ b/platform/msm_shared/interrupts.c
@@ -33,6 +33,11 @@
 #include <debug.h>
 
 extern int target_supports_qgic();
+extern enum handler_return gic_platform_irq(struct arm_iframe *frame);
+extern void gic_platform_fiq(struct arm_iframe *frame);
+extern status_t gic_mask_interrupt(unsigned int vector);
+extern status_t gic_unmask_interrupt(unsigned int vector);
+extern void gic_register_int_handler(unsigned int vector, int_handler func, void *arg);
 
 enum handler_return platform_irq(struct arm_iframe *frame)
 {
diff --git a/platform/msm_shared/mdp5.c b/platform/msm_shared/mdp5.c
index e13afd87c..81c366cc7 100755
--- a/platform/msm_shared/mdp5.c
+++ b/platform/msm_shared/mdp5.c
@@ -39,6 +39,7 @@
 #include <err.h>
 #include <clock.h>
 #include <scm.h>
+#include <target.h>
 
 #define MDP_MIN_FETCH		9
 #define MDSS_MDP_MAX_FETCH	12
@@ -172,7 +173,7 @@ static void mdss_source_pipe_config(struct fbcon_config *fb, struct msm_panel_in
 	dprintf(SPEW,"%s: src=%x fb_off=%x src_xy=%x dst_xy=%x\n",
 			 __func__, out_size, fb_off, src_xy, dst_xy);
 
-	writel(fb->base, pipe_base + PIPE_SSPP_SRC0_ADDR);
+	writel((uint32_t)fb->base, pipe_base + PIPE_SSPP_SRC0_ADDR);
 	writel(stride, pipe_base + PIPE_SSPP_SRC_YSTRIDE);
 	writel(src_size, pipe_base + PIPE_SSPP_SRC_IMG_SIZE);
 	writel(out_size, pipe_base + PIPE_SSPP_SRC_SIZE);
@@ -387,11 +388,11 @@ void mdss_intf_tg_setup(struct msm_panel_info *pinfo, uint32_t intf_base)
 	struct intf_timing_params itp = {0};
 
 	if (pinfo == NULL)
-		return ERR_INVALID_ARGS;
+		return;
 
 	lcdc =  &(pinfo->lcdc);
 	if (lcdc == NULL)
-		return ERR_INVALID_ARGS;
+		return;
 
 	adjust_xres = pinfo->xres;
 	if (pinfo->lcdc.split_display) {
diff --git a/platform/msm_shared/mipi_dsi.c b/platform/msm_shared/mipi_dsi.c
index e44dcd321..7296cefea 100644
--- a/platform/msm_shared/mipi_dsi.c
+++ b/platform/msm_shared/mipi_dsi.c
@@ -41,12 +41,20 @@
 #include <err.h>
 #include <msm_panel.h>
 #include <arch/ops.h>
+#include <target.h>
 
 extern void mdp_disable(void);
 extern int mipi_dsi_cmd_config(struct fbcon_config mipi_fb_cfg,
 			       unsigned short num_of_lanes);
 extern void mdp_shutdown(void);
 extern void mdp_start_dma(void);
+extern int mdp_get_revision();
+
+extern uint8_t target_panel_auto_detect_enabled();
+
+extern int mipi_dsi_phy_init(struct mipi_dsi_panel_config *);
+
+int mdss_dsi_cmds_rx(uint32_t **rp, int rp_len, int rdbk_len);
 
 #if (DISPLAY_TYPE_MDSS == 0)
 #define MIPI_DSI0_BASE MIPI_DSI_BASE
@@ -198,11 +206,11 @@ int mdss_dual_dsi_cmds_tx(struct mipi_dsi_cmd *cmds, int count)
 
 #if (DISPLAY_TYPE_MDSS == 1)
 	/* Align pload at 8 byte boundry */
-	off = pload;
+	off = (uint32_t)pload;
 	off &= 0x07;
 	if (off)
 		off = 8 - off;
-	off += pload;
+	off += (uint32_t)pload;
 
 	cm = cmds;
 	for (i = 0; i < count; i++) {
@@ -280,7 +288,7 @@ int mdss_dsi_cmds_rx(uint32_t **rp, int rp_len, int rdbk_len)
 	if (rdbk_len > 2) {
 		/*First 4 bytes + paded bytes will be header next len bytes would be payload */
 		for (i = 0; i < rdbk_len; i++) {
-			dp = *rp;
+			dp = (char *)*rp;
 			dp[i] = dp[(res + i) >> 2];
 		}
 	}
@@ -296,11 +304,11 @@ int mipi_dsi_cmds_tx(struct mipi_dsi_cmd *cmds, int count)
 	uint32_t off;
 
 	/* Align pload at 8 byte boundry */
-	off = pload;
+	off = (uint32_t)pload;
 	off &= 0x07;
 	if (off)
 		off = 8 - off;
-	off += pload;
+	off += (uint32_t)pload;
 
 	cm = cmds;
 	for (i = 0; i < count; i++) {
diff --git a/platform/msm_shared/mipi_dsi_autopll.c b/platform/msm_shared/mipi_dsi_autopll.c
index 4527e339d..96a17dbf8 100755
--- a/platform/msm_shared/mipi_dsi_autopll.c
+++ b/platform/msm_shared/mipi_dsi_autopll.c
@@ -32,6 +32,9 @@
 #include <smem.h>
 #include <mipi_dsi.h>
 #include <platform/iomap.h>
+#include <platform/timer.h>
+
+extern void mdss_dsi_phy_sw_reset(uint32_t ctl_base);
 
 #define LPFR_LUT_SIZE 10
 
diff --git a/platform/msm_shared/mipi_dsi_phy.c b/platform/msm_shared/mipi_dsi_phy.c
index 9fd69a4aa..e0a8e7aaa 100644
--- a/platform/msm_shared/mipi_dsi_phy.c
+++ b/platform/msm_shared/mipi_dsi_phy.c
@@ -30,6 +30,10 @@
 #include <reg.h>
 #include <mipi_dsi.h>
 #include <platform/iomap.h>
+#include <platform/timer.h>
+#include <arch/defines.h>
+
+extern int mdp_get_revision();
 
 #if (DISPLAY_TYPE_MDSS == 0)
 #define MIPI_DSI0_BASE MIPI_DSI_BASE
diff --git a/platform/msm_shared/mmc_sdhci.c b/platform/msm_shared/mmc_sdhci.c
index 80919dd94..a5206a515 100644
--- a/platform/msm_shared/mmc_sdhci.c
+++ b/platform/msm_shared/mmc_sdhci.c
@@ -849,6 +849,8 @@ static uint8_t mmc_card_supports_ddr_mode(struct mmc_card *card)
 		return 0;
 }
 
+extern void sdhci_msm_set_mci_clk(struct sdhci_host *host);
+
 /*
  * Function : Enable HS200 mode
  * Arg      : Host, card structure and bus width
@@ -1076,6 +1078,8 @@ uint32_t mmc_set_hs400_mode(struct sdhci_host *host,
 	return mmc_ret;
 }
 
+void clock_config_cdc(uint8_t slot);
+
 /*
  * Function: mmc_host_init
  * Arg     : mmc device structure
diff --git a/platform/msm_shared/mmc_wrapper.c b/platform/msm_shared/mmc_wrapper.c
index 9b808b510..a5bf60d2e 100755
--- a/platform/msm_shared/mmc_wrapper.c
+++ b/platform/msm_shared/mmc_wrapper.c
@@ -35,6 +35,7 @@
 #include <target.h>
 #include <string.h>
 #include <partition_parser.h>
+#include <boot_device.h>
 
 /*
  * Weak function for UFS.
diff --git a/platform/msm_shared/partition_parser.c b/platform/msm_shared/partition_parser.c
index 0dc62970b..b40e3ed1b 100644
--- a/platform/msm_shared/partition_parser.c
+++ b/platform/msm_shared/partition_parser.c
@@ -684,12 +684,12 @@ patch_gpt(uint8_t *gptImage, uint64_t density, uint32_t array_size,
 		      array_size, (long long)(card_size_sec - 34));
 
 	/* Updating CRC of the Partition entry array in both headers */
-	partition_entry_array_start = primary_gpt_header + block_size;
-	crc_value = calculate_crc32(partition_entry_array_start,
+	partition_entry_array_start = (unsigned)(primary_gpt_header + block_size);
+	crc_value = calculate_crc32((unsigned char *)partition_entry_array_start,
 				    max_part_count * part_entry_size);
 	PUT_LONG(primary_gpt_header + PARTITION_CRC_OFFSET, crc_value);
 
-	crc_value = calculate_crc32(partition_entry_array_start + array_size,
+	crc_value = calculate_crc32((unsigned char *)(partition_entry_array_start + array_size),
 				    max_part_count * part_entry_size);
 	PUT_LONG(secondary_gpt_header + PARTITION_CRC_OFFSET, crc_value);
 
@@ -796,7 +796,7 @@ static unsigned int write_gpt(uint32_t size, uint8_t *gptImage, uint32_t block_s
 	}
 
 	/* Writing the partition entries array for the primary header */
-	partition_entry_array_start = primary_gpt_header + block_size;
+	partition_entry_array_start = (unsigned)(primary_gpt_header + block_size);
 	ret = write_gpt_partition_array(primary_gpt_header,
 					partition_entry_array_start,
 					partition_entry_array_size, block_size);
@@ -807,8 +807,8 @@ static unsigned int write_gpt(uint32_t size, uint8_t *gptImage, uint32_t block_s
 	}
 
 	/*Writing the partition entries array for the backup header */
-	partition_entry_array_start = primary_gpt_header + block_size +
-	    partition_entry_array_size;
+	partition_entry_array_start = (unsigned)(primary_gpt_header + block_size +
+	    partition_entry_array_size);
 	ret = write_gpt_partition_array(secondary_gpt_header,
 					partition_entry_array_start,
 					partition_entry_array_size, block_size);
diff --git a/platform/msm_shared/qpic_nand.c b/platform/msm_shared/qpic_nand.c
index 3dc759d95..b3dda9ad2 100644
--- a/platform/msm_shared/qpic_nand.c
+++ b/platform/msm_shared/qpic_nand.c
@@ -1494,7 +1494,7 @@ qpic_nand_read_page(uint32_t page, unsigned char* buffer, unsigned char* sparead
 
 		bam_add_cmd_element(cmd_list_ptr, NAND_FLASH_STATUS, (uint32_t)PA((addr_t)&(flash_sts[i])), CE_READ_TYPE);
 
-		cmd_list_temp = cmd_list_ptr;
+		cmd_list_temp = (uint32_t *)cmd_list_ptr;
 
 		cmd_list_ptr++;
 
diff --git a/platform/msm_shared/reboot.c b/platform/msm_shared/reboot.c
index 4c21d1179..1bdca346c 100644
--- a/platform/msm_shared/reboot.c
+++ b/platform/msm_shared/reboot.c
@@ -38,6 +38,8 @@
 #include <reboot.h>
 #include <qtimer.h>
 
+extern void pmic_reset_configure(uint8_t reset_type);
+
 #if USER_FORCE_RESET_SUPPORT
 /* Return 1 if it is a force resin triggered by user. */
 uint32_t is_user_force_reset(void)
diff --git a/platform/msm_shared/scm.c b/platform/msm_shared/scm.c
index 334bca485..d96ab0e2a 100644
--- a/platform/msm_shared/scm.c
+++ b/platform/msm_shared/scm.c
@@ -33,6 +33,7 @@
 #include <bits.h>
 #include <arch/ops.h>
 #include <dload_util.h>
+#include <rand.h>
 #include "scm.h"
 
 #pragma GCC optimize ("O0")
@@ -192,7 +193,7 @@ static int scm_call_atomic(uint32_t svc, uint32_t cmd, uint32_t arg1)
 {
 	uint32_t context_id;
 	register uint32_t r0 __asm__("r0") = SCM_ATOMIC(svc, cmd, 1);
-	register uint32_t r1 __asm__("r1") = &context_id;
+	register uint32_t r1 __asm__("r1") = (uint32_t)&context_id;
 	register uint32_t r2 __asm__("r2") = arg1;
 
 	__asm__ volatile(
@@ -221,7 +222,7 @@ int scm_call_atomic2(uint32_t svc, uint32_t cmd, uint32_t arg1, uint32_t arg2)
 {
 	int context_id;
 	register uint32_t r0 __asm__("r0") = SCM_ATOMIC(svc, cmd, 2);
-	register uint32_t r1 __asm__("r1") = &context_id;
+	register uint32_t r1 __asm__("r1") = (uint32_t)&context_id;
 	register uint32_t r2 __asm__("r2") = arg1;
 	register uint32_t r3 __asm__("r3") = arg2;
 
@@ -443,7 +444,7 @@ static int ssd_image_is_encrypted(uint32_t ** img_ptr, uint32_t * img_len_ptr, u
 			scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_SSD, SSD_PARSE_MD_ID);
 			scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_VALUE,SMC_PARAM_TYPE_BUFFER_READWRITE);
 			scm_arg.x2 = parse_req.md_len;
-			scm_arg.x3 = parse_req.md;
+			scm_arg.x3 = (uint32_t)parse_req.md;
 			scm_arg.atomic = true;
 
 			ret = scm_call2(&scm_arg, &scm_ret);
@@ -529,7 +530,7 @@ int decrypt_scm_v2(uint32_t ** img_ptr, uint32_t * img_len_ptr)
 				scm_arg.x2 = decrypt_req.md_ctx_id;
 				scm_arg.x3 = decrypt_req.last_frag;
 				scm_arg.x4 = decrypt_req.frag_len;
-				scm_arg.x5[0] = decrypt_req.frag;
+				scm_arg.x5[0] = (uint32_t)decrypt_req.frag;
 
 				ret = scm_call2(&scm_arg, &scm_ret);
 				decrypt_rsp.status = scm_ret.x1;
@@ -672,7 +673,7 @@ int scm_protect_keystore(uint32_t * img_ptr, uint32_t  img_len)
 	{
 		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_SSD, SSD_PROTECT_KEYSTORE_ID);
 		scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_BUFFER_READWRITE,SMC_PARAM_TYPE_VALUE);
-		scm_arg.x2 = protect_req.keystore_ptr;
+		scm_arg.x2 = (uint32_t)protect_req.keystore_ptr;
 		scm_arg.x3 = protect_req.keystore_len;
 
 		ret = scm_call2(&scm_arg, &scm_ret);
@@ -723,7 +724,7 @@ void set_tamper_fuse_cmd()
 	{
 		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_FUSE, SCM_BLOW_SW_FUSE_ID);
 		scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_BUFFER_READWRITE,SMC_PARAM_TYPE_VALUE);
-		scm_arg.x2  = cmd_buf;
+		scm_arg.x2 = (uint32_t)cmd_buf;
 		scm_arg.x3 = cmd_len;
 
 		scm_call2(&scm_arg, NULL);
@@ -763,7 +764,7 @@ uint8_t get_tamper_fuse_cmd()
 	{
 		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_FUSE, SCM_IS_SW_FUSE_BLOWN_ID);
 		scm_arg.x1 = MAKE_SCM_ARGS(0x2,SMC_PARAM_TYPE_BUFFER_READWRITE,SMC_PARAM_TYPE_VALUE);
-		scm_arg.x2  = cmd_buf;
+		scm_arg.x2 = (uint32_t)cmd_buf;
 		scm_arg.x3 = cmd_len;
 
 		scm_call2(&scm_arg, &scm_ret);
@@ -815,7 +816,7 @@ void save_kernel_hash_cmd(void *digest)
 		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_ES, SCM_SAVE_PARTITION_HASH_ID);
 		scm_arg.x1 = MAKE_SCM_ARGS(0x3, 0, SMC_PARAM_TYPE_BUFFER_READWRITE);
 		scm_arg.x2 = req.partition_id;
-		scm_arg.x3 = (uint8_t *)&req.digest;
+		scm_arg.x3 = (uint32_t)(uint8_t *)&req.digest;
 		scm_arg.x4 = sizeof(req.digest);
 
 		if (scm_call2(&scm_arg, NULL))
@@ -1046,7 +1047,7 @@ void scm_elexec_call(paddr_t kernel_entry, paddr_t dtb_offset)
 	{
 		scm_arg.x0 = MAKE_SIP_SCM_CMD(SCM_SVC_MILESTONE_32_64_ID, SCM_SVC_MILESTONE_CMD_ID);
 		scm_arg.x1 = MAKE_SCM_ARGS(0x2, SMC_PARAM_TYPE_BUFFER_READ);
-		scm_arg.x2 = (void *)&param;
+		scm_arg.x2 = (uint32_t)&param;
 		scm_arg.x3 = sizeof(el1_system_param);
 
 		/* First try a hypervisor call to jump to EL2 if supported */
@@ -1279,7 +1280,7 @@ uint32_t is_secure_boot_enable()
 	resp =  memalign(CACHE_LINE,(2 *sizeof(uint32_t)));
 	ASSERT(resp);
 	if (!scm_arm_support) {
-		ret = scm_call_atomic2(TZBSP_SVC_INFO, IS_SECURE_BOOT_ENABLED, resp, (2 * sizeof(uint32_t)));
+		ret = scm_call_atomic2(TZBSP_SVC_INFO, IS_SECURE_BOOT_ENABLED, (uint32_t)resp, (2 * sizeof(uint32_t)));
 	} else {
 		scm_arg.x0 = MAKE_SIP_SCM_CMD(TZBSP_SVC_INFO, IS_SECURE_BOOT_ENABLED);
 		ret = scm_call2(&scm_arg, &scm_ret);
diff --git a/platform/msm_shared/sdhci_msm.c b/platform/msm_shared/sdhci_msm.c
index d72d90df6..0e053bf3d 100644
--- a/platform/msm_shared/sdhci_msm.c
+++ b/platform/msm_shared/sdhci_msm.c
@@ -77,10 +77,11 @@ static const uint32_t tuning_block_128[] = {
  *           Once we receive the interrupt, we will ack the power control
  *           register that we have successfully completed pmic transactions
  */
-static enum handler_return sdhci_int_handler(struct sdhci_msm_data *data)
+static enum handler_return sdhci_int_handler(void *vdata)
 {
 	uint32_t ack;
 	uint32_t status;
+	struct sdhci_msm_data *data = (struct sdhci_msm_data *)vdata;
 
 	/*
 	 * Read the mask register to check if BUS & IO level
diff --git a/platform/msm_shared/shutdown_detect.c b/platform/msm_shared/shutdown_detect.c
index a51c9ae99..0f0e3a9e8 100644
--- a/platform/msm_shared/shutdown_detect.c
+++ b/platform/msm_shared/shutdown_detect.c
@@ -33,8 +33,11 @@
 #include <pm8x41_hw.h>
 #include <kernel/timer.h>
 #include <platform/timer.h>
+#include <target.h>
 #include <shutdown_detect.h>
 
+extern uint32_t platform_get_sclk_count(void);
+
 /* sleep clock is 32.768 khz, 0x8000 count per second */
 #define MPM_SLEEP_TIMETICK_COUNT    0x8000
 #define PWRKEY_LONG_PRESS_COUNT     0xC000
@@ -82,8 +85,7 @@ static uint32_t is_pwrkey_pon_reason()
  * Shutdown the device if power key is release before
  * (PWRKEY_LONG_PRESS_COUNT/MPM_SLEEP_TIMETICK_COUNT) seconds.
  */
-static enum handler_return long_press_pwrkey_timer_func(struct timer *p_timer,
-	void *arg)
+static enum handler_return long_press_pwrkey_timer_func(struct timer *p_timer, unsigned long arg0, void *arg1)
 {
 	uint32_t sclk_count = platform_get_sclk_count();
 
diff --git a/platform/msm_shared/smem.c b/platform/msm_shared/smem.c
index 04a801802..1bdea1d26 100644
--- a/platform/msm_shared/smem.c
+++ b/platform/msm_shared/smem.c
@@ -136,11 +136,11 @@ void* smem_get_alloc_entry(smem_mem_type_t type, uint32_t* size)
 	smem = (struct smem *)smem_addr;
 
 	if (type < SMEM_FIRST_VALID_TYPE || type > SMEM_LAST_VALID_TYPE)
-		return 1;
+		return ret;
 
 	ainfo = &smem->alloc_info[type];
 	if (readl(&ainfo->allocated) == 0)
-		return 1;
+		return ret;
 
 	*size = readl(&ainfo->size);
 	base_ext = readl(&ainfo->base_ext);
@@ -148,7 +148,7 @@ void* smem_get_alloc_entry(smem_mem_type_t type, uint32_t* size)
 
 	if(base_ext)
 	{
-		ret = base_ext + offset;
+		ret = (void *)base_ext + offset;
 	}
 	else
 	{
diff --git a/platform/msm_shared/spmi.c b/platform/msm_shared/spmi.c
index 6d486b729..6089ed0d3 100644
--- a/platform/msm_shared/spmi.c
+++ b/platform/msm_shared/spmi.c
@@ -26,10 +26,12 @@
  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "sys/types.h"
 #include <debug.h>
 #include <reg.h>
 #include <spmi.h>
 #include <bits.h>
+#include <malloc.h>
 #include <platform/iomap.h>
 #include <platform/irqs.h>
 #include <platform/interrupts.h>
@@ -127,7 +129,7 @@ static void write_wdata_from_array(uint8_t *array,
 unsigned int pmic_arb_write_cmd(struct pmic_arb_cmd *cmd,
                                 struct pmic_arb_param *param)
 {
-	uint32_t bytes_written = 0;
+	uint8_t bytes_written = 0;
 	uint32_t error;
 	uint32_t val = 0;
 
@@ -358,7 +360,7 @@ int spmi_acc_irq(uint32_t periph_acc_irq, uint32_t status)
 		return 0;
 }
 
-void spmi_irq()
+enum handler_return spmi_irq(void *)
 {
 	int i;
 	uint32_t status;
@@ -372,9 +374,11 @@ void spmi_irq()
 		if (status)
 			if (!spmi_acc_irq(i, status))
 				/* Not the correct interrupt, continue to wait */
-				return;
+				return INT_NO_RESCHEDULE;
 	}
 	mask_interrupt(EE0_KRAIT_HLOS_SPMI_PERIPH_IRQ);
+
+	return INT_NO_RESCHEDULE;
 }
 
 /* Enable interrupts on a particular peripheral: periph_id */
diff --git a/platform/msm_shared/usb30_dwc_hw.h b/platform/msm_shared/usb30_dwc_hw.h
index 56b32bac1..428f3fc4c 100644
--- a/platform/msm_shared/usb30_dwc_hw.h
+++ b/platform/msm_shared/usb30_dwc_hw.h
@@ -36,6 +36,7 @@ void dwc_ep_cmd_stall(dwc_dev_t *dev, uint8_t ep_phy_num);
 void dwc_ep_cmd_start_new_config(dwc_dev_t *dev,
 								 uint8_t ep_phy_num,
 								 uint8_t resource_idx);
+void dwc_ep_cmd_clear_stall(dwc_dev_t *dev, uint8_t ep_phy_num);
 
 void dwc_ep_enable(dwc_dev_t *dev, uint8_t ep_phy_num);
 void dwc_ep_disable(dwc_dev_t *dev, uint8_t ep_phy_num);
diff --git a/platform/msm_shared/usb30_udc.c b/platform/msm_shared/usb30_udc.c
index 619289917..0bd548263 100644
--- a/platform/msm_shared/usb30_udc.c
+++ b/platform/msm_shared/usb30_udc.c
@@ -47,6 +47,8 @@
 #include <board.h>
 #include <platform/timer.h>
 
+#include "usb30_dwc_hw.h"
+
 //#define DEBUG_USB
 
 #ifdef DEBUG_USB
diff --git a/target/msm8226/init.c b/target/msm8226/init.c
index 320a1bd13..684633dcd 100644
--- a/target/msm8226/init.c
+++ b/target/msm8226/init.c
@@ -37,6 +37,7 @@
 #include <mmc_sdhci.h>
 #include <platform/clock.h>
 #include <platform/gpio.h>
+#include <platform/timer.h>
 #include <spmi.h>
 #include <board.h>
 #include <smem.h>
@@ -49,6 +50,9 @@
 #include <scm.h>
 #include <stdlib.h>
 #include <partition_parser.h>
+#include <sdhci_msm.h>
+
+extern void crypto_eng_cleanup();
 
 #if LONG_PRESS_POWER_ON
 #include <shutdown_detect.h>
diff --git a/target/msm8916/init.c b/target/msm8916/init.c
index e0943d546..3de479b0e 100644
--- a/target/msm8916/init.c
+++ b/target/msm8916/init.c
@@ -46,12 +46,15 @@
 #include <platform/gpio.h>
 #include <platform/irqs.h>
 #include <platform/clock.h>
+#include <platform/timer.h>
 #include <crypto5_wrapper.h>
 #include <partition_parser.h>
 #include <stdlib.h>
 #include <secapp_loader.h>
 #include <rpmb.h>
 #include <smem.h>
+#include <sdhci_msm.h>
+#include <spmi.h>
 #include <lk2nd.h>
 
 #if LONG_PRESS_POWER_ON
@@ -96,6 +99,7 @@ static uint32_t  mmc_sdc_pwrctl_irq[] =
         { SDCC1_PWRCTL_IRQ, SDCC2_PWRCTL_IRQ };
 
 extern void target_try_load_qhypstub();
+extern void crypto_eng_cleanup();
 
 void target_early_init(void)
 {
diff --git a/target/msm8974/init.c b/target/msm8974/init.c
index 41ea1976b..beac1ffdf 100644
--- a/target/msm8974/init.c
+++ b/target/msm8974/init.c
@@ -49,7 +49,15 @@
 #include <scm.h>
 #include <platform/clock.h>
 #include <platform/gpio.h>
+#include <platform/timer.h>
 #include <stdlib.h>
+#include <string.h>
+#include <sdhci_msm.h>
+
+extern int platform_is_8974();
+extern int platform_is_8974ac();
+extern int platform_is_8974Pro();
+extern void crypto_eng_cleanup();
 
 #define HW_PLATFORM_8994_INTERPOSER    0x3
 
-- 
2.43.2

